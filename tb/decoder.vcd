$version Generated by VerilatedVcd $end
$date Fri Jun  6 20:55:35 2025 $end
$timescale 1ns $end

 $scope module TOP $end
  $var wire  1 & clk $end
  $var wire  4 4 decoded_alu_instruction [3:0] $end
  $var wire  1 - decoded_branch $end
  $var wire  1 5 decoded_halt $end
  $var wire 32 0 decoded_immediate [31:0] $end
  $var wire  1 , decoded_mem_read_enable $end
  $var wire  1 + decoded_mem_write_enable $end
  $var wire  5 1 decoded_rd_address [4:0] $end
  $var wire  3 . decoded_reg_input_mux [2:0] $end
  $var wire  1 * decoded_reg_write_enable $end
  $var wire  5 2 decoded_rs1_address [4:0] $end
  $var wire  5 3 decoded_rs2_address [4:0] $end
  $var wire  1 / decoded_scalar_instruction $end
  $var wire 32 ) instruction [31:0] $end
  $var wire  1 ' reset $end
  $var wire  3 ( warp_state [2:0] $end
  $scope module decoder $end
   $var wire  1 & clk $end
   $var wire  4 4 decoded_alu_instruction [3:0] $end
   $var wire  1 - decoded_branch $end
   $var wire  1 5 decoded_halt $end
   $var wire 32 0 decoded_immediate [31:0] $end
   $var wire  1 , decoded_mem_read_enable $end
   $var wire  1 + decoded_mem_write_enable $end
   $var wire  5 1 decoded_rd_address [4:0] $end
   $var wire  3 . decoded_reg_input_mux [2:0] $end
   $var wire  1 * decoded_reg_write_enable $end
   $var wire  5 2 decoded_rs1_address [4:0] $end
   $var wire  5 3 decoded_rs2_address [4:0] $end
   $var wire  1 / decoded_scalar_instruction $end
   $var wire  3 : funct3 [2:0] $end
   $var wire  4 < funct4 [3:0] $end
   $var wire 18 $ imm_b [17:0] $end
   $var wire 14 > imm_i [13:0] $end
   $var wire 28 % imm_j [27:0] $end
   $var wire 15 ? imm_load [14:0] $end
   $var wire 15 # imm_s [14:0] $end
   $var wire 20 @ imm_u [31:12] $end
   $var wire  6 7 inst [5:0] $end
   $var wire 32 ) instruction [31:0] $end
   $var wire  3 8 opcode [2:0] $end
   $var wire  5 9 rd [4:0] $end
   $var wire  1 ' reset $end
   $var wire  5 ; rs1 [4:0] $end
   $var wire  5 = rs2 [4:0] $end
   $var wire  1 6 scalar $end
   $var wire  3 ( warp_state [2:0] $end
  $upscope $end
 $upscope $end
$enddefinitions $end


#0
b000000000000000 #
b000000000000000000 $
b0000000000000000000000000000 %
0&
1'
b000 (
b00000000000000000000000000000000 )
0*
0+
0,
0-
b000 .
0/
b00000000000000000000000000000000 0
b00000 1
b00000 2
b00000 3
b0000 4
05
06
b000000 7
b000 8
b00000 9
b000 :
b00000 ;
b0000 <
b00000 =
b00000000000000 >
b000000000000000 ?
b00000000000000000000 @
#1
1&
b1010 4
#2
0&
0'
#3
1&
#4
b000000000000001 #
b000000000000000100 $
b0000000000000110000100000100 %
0&
b010 (
b00000000000000001100000001000001 )
16
b000001 7
b00001 9
b100 :
b00010 ;
b00011 =
b00000000000011 >
b000000000000011 ?
b00000000000001100000 @
#5
1&
1*
1/
b00001 1
b00010 2
b00011 3
b0000 4
#6
0&
b00000000000000001100010001000001 )
b0001 <
b00000000000001100010 @
#7
1&
b0001 4
#8
0&
b00000000000000001100100001000001 )
b0010 <
b00000000000001100100 @
#9
1&
b0010 4
#10
0&
b00000000000000001100110001000001 )
b0011 <
b00000000000001100110 @
#11
1&
b0011 4
#12
0&
b00000000000000001101000001000001 )
b101 :
b0100 <
b00000000000001101000 @
#13
1&
b0100 4
#14
0&
b00000000000000001101010001000001 )
b0101 <
b00000000000001101010 @
